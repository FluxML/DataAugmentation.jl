{"attributes":{"backlinks":[],"path":"/home/runner/.julia/packages/DataAugmentation/zwubD/docs/literate/intro.md","title":"DataAugmentation.jl"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["DataAugmentation.jl"],"type":"node"},{"attributes":{},"tag":"p","children":["This library provides data transformations for machine and deep learning. At the moment, it focuses on spatial data (think images, keypoint data and masks), but that is owed only to my current work. The extensible abstractions should fit other domains as well."],"type":"node"},{"attributes":{},"tag":"p","children":["For the most part, the transformations themselves are not very complex. The challenge this library tackles is to reconcile an easy-to-use, composable interface with performant execution."],"type":"node"},{"attributes":{},"tag":"p","children":["The key abstractions are ",{"attributes":{},"tag":"code","children":["Transform"],"type":"node"},"s, the transformation to apply, and ",{"attributes":{},"tag":"code","children":["Item"],"type":"node"},"s which contain the data to be transformed. ",{"attributes":{"reftype":"symbol","document_id":"references/DataAugmentation.apply"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["apply"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"code","children":["(tfm, item)"],"type":"node"},", as the name gives away, applies a transformation to an item.  For example, given an ",{"attributes":{"reftype":"symbol","document_id":"references/DataAugmentation.Image"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Image"],"type":"node"}],"type":"node"}," item, we can resize it with the ",{"attributes":{"reftype":"symbol","document_id":"references/DataAugmentation.CenterResizeCrop"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["CenterResizeCrop"],"type":"node"}],"type":"node"}," transformation."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["item"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DataAugmentation.Image"},"tag":"reference","children":["Image"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["image"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["tfm"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DataAugmentation.CenterResizeCrop"},"tag":"reference","children":["CenterResizeCrop"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"TUPLE","children":[{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["128"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["128"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DataAugmentation.apply"},"tag":"reference","children":["apply"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["tfm"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["item"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Requirements"],"type":"node"},{"attributes":{},"tag":"p","children":["The above example is simple, but there are more requirements of data augmentation pipelines that this library adresses. They serve as a motivation to the interface I've arrived at for defining transformations."],"type":"node"},{"attributes":{},"tag":"h3","children":["Stochasticity"],"type":"node"},{"attributes":{},"tag":"p","children":["A transformation is stochastic (as opposed to deterministic) if it produces different outputs based on some random state. This randomness can become a problem when applying an transformation to an aligned pair of input and target. If we have an image and a corresponding segmentation mask, using different scaling factors results in misalignment of the two; the segmentation no longer matches up with the image pixels."],"type":"node"},{"attributes":{},"tag":"p","children":["To handle this, the random state is explicitly passed to the transformations, rendering them deterministic. A generator for the random state can be defined with ",{"attributes":{"reftype":"symbol","document_id":"references/DataAugmentation.getrandstate"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["getrandstate"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"code","children":["(tfm)"],"type":"node"}," and passed to ",{"attributes":{},"tag":"code","children":["apply"],"type":"node"}," with the ",{"attributes":{},"tag":"code","children":["randstate"],"type":"node"}," keyword argument."],"type":"node"},{"attributes":{},"tag":"h3","children":["Composition"],"type":"node"},{"attributes":{},"tag":"p","children":["Most data augmentation pipelines are made up of multiple steps: augmenting an image can mean resizing, randomly rotating, cropping and then normalizing the values. So applying transformations one after another – sequencing – is one way to compose transformations. But some operations, like affine transformations, can also be ",{"attributes":{},"tag":"em","children":["fused"],"type":"node"},", resulting in a single transformation that is more performant and produces more accurate results."],"type":"node"},{"attributes":{},"tag":"h3","children":["Buffering"],"type":"node"},{"attributes":{},"tag":"p","children":["Since data augmentation pipelines often run on large amounts of data, performance can often be improved by using prealloacted output buffers for the transformations. This results in fewer memory allocations and less garbage collection which both take time."],"type":"node"},{"attributes":{},"tag":"hr","children":[],"type":"node"},{"attributes":{},"tag":"p","children":["Let's next see how these requirements are reflected in the ",{"attributes":{"reftype":"document","href":"./iteminterface.md","title":"","document_id":"documents/docs/literate/iteminterface.md"},"tag":"reference","children":["item"],"type":"node"}," and ",{"attributes":{"reftype":"document","href":"./tfminterface.md","title":"","document_id":"documents/docs/literate/tfminterface.md"},"tag":"reference","children":["transformation"],"type":"node"}," interfaces."],"type":"node"}],"type":"node"}],"type":"node"}