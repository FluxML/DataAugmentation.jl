<HTML><head><title>Transformation interface</title><link href=../../template/hugobook.css rel=stylesheet ></link><meta content=Type=text/html; charset=utf-8 http-equiv=Content-Type ></meta></head><body><input onclick=toggleMenu() id=menu-control class=hidden toggle type=checkbox ></input><input id=toc-control type=checkbox class=hidden toggle ></input><main class=container flex ><aside id=menu-container class=book-menu ><nav class=book-menu-content ><h2 id=title >DataAugmentation.jl</h2><div id=sidebar ><div class=doctree ><body><ul><li><p>User guide (TODO)</p><ul><li><p><a href=quickstart.md.html title= >Quickstart</a></p></li></ul></li><li><p>Library</p><ul><li><p><a href=intro.md.html title= >Introduction</a></p></li><li><p><a href=iteminterface.md.html title= >Item interface</a></p></li><li><p><a href=tfminterface.md.html title= >Transformation interface</a></p></li><li><p><a href=buffering.md.html title= >Buffering</a></p></li><li><p>Projective transformations</p><ul><li><p><a href=projective/intro.md.html title= >Introduction</a></p></li><li><p><a href=projective/interface.md.html title= >Interface</a></p></li><li><p><a href=projective/data.md.html title= >Spatial data</a></p></li><li><p><a href=projective/usage.md.html title= >Usage</a></p></li><li><p><a href=projective/gallery.md.html title= >Gallery</a></p></li></ul></li><li><p><a href=preprocessing.md.html title= >Preprocessing</a></p></li><li><p><a href=stochastic.md.html title= >Stochastic transformations</a></p></li><li><p><a href=colortransforms.md.html title= >Color transformations</a></p></li></ul></li><li><p><a href=../../REFERENCE.html title= >Reference</a></p></li></ul></body></div></div></nav></aside><div class=book-page ><header class=book-header ></header><article><h1 id=transformation-interface >Transformation interface</h1><p style=opacity:60%; ><em><a href=../../src/base.jl.html title= ><code>base.jl</code></a></em></p><p>The transformation interface is the centrepiece of this library. Beside straightforward transform application it also enables stochasticity, composition and buffering.</p><p>A transformation is a type that subtypes <a href=../../REFERENCE/DataAugmentation.Transform.html ><code>Transform</code></a>. The only <em>required</em> function to implement for your transformation type <code>T</code> is</p><ul><li><p><a href=../../REFERENCE/DataAugmentation.apply.html ><code>apply</code></a><code>(tfm::T, item::I; randstate)</code></p><p>Applies the transformation <code>tfm</code> to item <code>item</code>. Implemented methods can of course dispatch on the type of <code>item</code>. <code>randstate</code> encapsulates the random state needed for stochastic transformations. The <code>apply</code> method implementation itself should be deterministic.</p><p>You may dispatch on a specific item type <code>I</code> or use the abstract <code>Item</code> if one implementation works for all item types.</p></li></ul><p>You may additionally also implement:</p><ul><li><p><a href=../../REFERENCE/DataAugmentation.getrandstate.html ><code>DataAugmentation.getrandstate</code></a><code>(tfm)</code> for <em>stochastic</em> transformations</p><p>Generates random state to be used inside <code>apply</code>. Calling <code>apply(tfm, item)</code> is equivalent to<br></br><code>apply(tfm, item; randstate = getrandstate(tfm))</code>. It defaults to <code>nothing</code>, so we need not implement it for deterministic transformations.</p></li><li><p><a href=../../REFERENCE/DataAugmentation.apply!.html ><code>apply!</code></a><code>(bufitem, tfm::T, item; randstate)</code> to support <em>buffering</em></p><p>Buffered version of <code>apply</code> that mutates <code>bufitem</code>. If not implemented,<br></br>falls back to regular <code>apply</code>.</p></li><li><p><a href=../../REFERENCE/DataAugmentation.compose.html ><code>DataAugmentation.compose</code></a><code>(tfm1, tfm2)</code> for custom <em>composition</em> with other transformations</p><p>Composes transformations. By default, returns a <a href=../../REFERENCE/DataAugmentation.Sequence.html ><code>Sequence</code></a> transformation that applies the transformations one after the other.</p></li></ul><h3 id=example >Example</h3><p>The implementation of the <a href=../../REFERENCE/DataAugmentation.MapElem.html ><code>MapElem</code></a> transformation illustrates this interface well. It transforms any item with array data by mapping a function over the array’s elements, just like <code>Base.map</code>.</p><pre lang=julia ><code>struct MapElem &lt;: Transform
    f
end
</code></pre><p>The <code>apply</code> implementation dispatches on <a href=../../REFERENCE/DataAugmentation.AbstractArrayItem.html ><code>DataAugmentation.AbstractArrayItem</code></a>, an abstract item type for items that wrap arrays. Note that the <code>randstate</code> keyword argument needs to be given even for implementations of deterministic transformations. We also make use of the <a href=../../REFERENCE/DataAugmentation.setdata.html ><code>DataAugmentation.setdata</code></a> helper to update the item data.</p><pre lang=julia ><code>function apply(tfm::MapElem, item::AbstractArrayItem; randstate = nothing)
    a = itemdata(item)
    a_ = map(tfm.f, a)
    return setdata(item, a_)
end
</code></pre><p>The buffered version applies the function inplace using <code>Base.map!</code>:</p><pre lang=julia ><code>function apply!(
        bufitem::I,
        tfm::MapElem,
        item::I;
        randstate = nothing) where I &lt;: AbstractArrayItem
    map!(tfm.f, itemdata(bufitem), itemdata(item))
    return bufitem
end
</code></pre><p>Finally, a <code>MapElem</code> can also be composed nicely with other <code>MapElem</code>s. Instead of applying them sequentially, the functions are fused and applied once.</p><pre lang=julia ><code>compose(tfm1::MapElem, tfm2::MapElem2) = MapElem(tfm2.f ∘ tfm1.f)
</code></pre></article><footer class=book-footer ></footer></div><aside class=book-toc ><nav id=toc class=book-toc-content ><ul><li><a href=#transformation-interface >Transformation interface</a><ul></ul></li></ul></nav></aside></main></body></HTML>